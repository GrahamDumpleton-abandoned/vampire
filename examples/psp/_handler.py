from mod_python import apache

import os
import sys
import vampire

# We can't use the "import" statement for "psp" because
# of strange problems in mod_python module loader.
# Namely, if "import" is used and PythonHandler is
# defined elsewhere as "mod_python.psp" and it gets
# loaded before this code, the "psp" module can not then
# be found. Instead use the mod_python module loader
# itself as then it always works.

#from mod_python import psp
psp = apache.import_module("mod_python.psp")


# Handler for serving up PSP files. The handler will
# maintain compatibility with how standard PSP works,
# except that the ".psp" extension isn't used. Depending
# on how Vampire configuration is setup, either ".html"
# extension is used, or REST style URL with no actual
# extension.

def handler(req):

  # We only want to treat request as being a possible
  # request for a PSP template file if there exists a
  # ".psp" file.

  path = os.path.splitext(req.filename)[0] + ".psp"

  if not os.path.exists(path):
    return apache.DECLINED

  # PSP template files are always HTML files.

  req.content_type = "text/html"

  # Trigger parsing of the PSP file. The file cache
  # for PSP files is still being used here.

  template = psp.PSP(req,filename=path)

  # Routine which actually executes the resultant
  # code for the PSP page. Separated into a function
  # as need to be able to execute same code for
  # a nested error page.

  def _run(req,template,vars={}):

    code = template.code

    # Check whether the code is trying to make use of
    # sessions. If it is, first look for session created
    # externally and stored in the req object. If this
    # doesn't exist only then create a session object.

    session = None

    if "session" in code.co_names:
      if not hasattr(req,"session"):
	session = Session.Session(req)
      req.session = session

    # Check whether the code is trying to make use of the
    # form object. If it is, ensure that form object has
    # been created. Cache the actual form fields as well.

    form = None
    fields = None

    if "form" in code.co_names:
      fields = vampire.processForm(req)
      form = req.form

    # Check whether the code is trying to make use of
    # the form fields. If it is, grab the actual form
    # fields if it hasn't been done already. This is an
    # addition on top of what original PSP and gives
    # access to the structured form fields generated by
    # Vampire.

    if fields is None:
      if "fields" in code.co_names:
	fields = vampire.processForm(req)
      else:
        fields = {}

    # Create PSP interface object for compatibility.

    interface = psp.PSPInterface(req,template.filename,form)

    # Build up the execution environment to be used.
    # Defaults from Vampire configuration are also pushed
    # into the environment so that these can be used. If
    # user defined settings are placed into the "DEFAULT"
    # section of configuration file, these will also be
    # available. Note that don't copy globals from module
    # like in original PSP as that means contents of this
    # module could be trashed.

    environ = {}

    config = vampire.loadConfig(req,".vampire")

    environ.update(config.defaults())

    environ["req"] = req
    environ["form"] = form
    environ["fields"] = fields
    environ["psp"] = interface

    if hasattr(req,"session"):
      environ["session"] = req.session
    else:
      environ["session"] = None

    environ.update(vars)

    # Now execute the actual page to handle the request.

    try:

      try:
	exec code in environ

	req.flush()

	# Always ensure that session object is saved.

	if session is not None:
	  session.save()
	elif hasattr(req,"session"):
	  req.session.save()

      except: 
	et,ev,etb = sys.exc_info()

	# Use error page to display details of error if
	# an actual error page was supplied.

	if interface.error_page:
	  _run(req,template.error_page,{"exception":(et,ev,etb)})

	else:
	  raise et,ev,etb

    finally:

      # Don't unlock session object like original PSP
      # code did, as register cleanup function should do
      # it anyway, and unlocking it here means that
      # can't use it in a log handler.

      #if session is not None:
      #	session.unlock()

      pass

  # Execute the actual PSP template.

  _run(req,template)


# Also link handler to that for ".html" requests. Which
# is used and thus whether REST style URLs are used or
# requests with a ".html" extension is dictated by how
# settings are defined in the Vampire configuration
# file.

handler_html = handler                                                          


# Block access to raw PSP files.

def handler_psp(req):
  if os.path.exists(req.filename):
    return apache.HTTP_NOT_FOUND
  return apache.DECLINED
