from mod_python import apache

import os
import sys
import vampire

# We can't use the "import" statement for "psp" because
# of strange problems in mod_python module loader.
# Namely, if "import" is used and PythonHandler is
# defined elsewhere as "mod_python.psp" and it gets
# loaded before this code, the "psp" module can not then
# be found. Instead use the mod_python module loader
# itself as then it always works.

#from mod_python import psp
psp = apache.import_module("mod_python.psp")


# Customised version of the PSP class which tailors
# execution of PSP pages to the Vampire execution
# environment. This will allow Vampire import hooks to
# work correctly where PSP code is in a file. The
# actual form fields are also made available directly.

class PSP(psp.PSP):

  def run(self,vars={}):

    code,req = self.code,self.req

    # Check whether the code is trying to make use of
    # session object. If it is, first look for session
    # created externally and stored in the req object.
    # If this doesn't exist only then create a session
    # object.

    session = None

    if "session" in code.co_names:
      if not hasattr(req,"session"):
        req.session = Session.Session(req)
        session = req.session

    # Check whether the code is trying to make use of
    # the form object or the fields object. If either is
    # used, ensure that form object has been created and
    # cache the form fields. The fields object is an
    # addition to that which the original PSP provided
    # and gives access to the structured form fields
    # which are generated by Vampire.

    form = None
    fields = {}

    if "form" in code.co_names or "fields" in code.co_names:
      fields = vampire.processForm(req)
      form = req.form

    # Create the PSP interface object.

    interface = psp.PSPInterface(req,self.filename,form)

    # Build up the execution environment to be used.
    # Defaults from Vampire configuration are also
    # pushed into the environment so that these can be
    # used. If user defined settings are placed into the
    # "DEFAULT" section of configuration file, these
    # will also be available. Note that only populate
    # environment with just methods and classes that are
    # documented as being available within PSP page or
    # which make sense to be made available.

    environ = {}

    environ["__builtins__"] = __builtins__

    environ["PSP"] = PSP
    environ["parse"] = psp.parse
    environ["parsestring"] = psp.parsestring

    config = vampire.loadConfig(req,".vampire")

    environ.update(config.defaults())

    environ["__req__"] = req

    if self.filename:
      environ["__file__"] = self.filename

    environ["req"] = req

    environ["form"] = form
    environ["fields"] = fields
    environ["psp"] = interface
    environ["session"] = session

    environ.update(self.vars)
    environ.update(vars)

    # Now execute the actual page to handle the request.

    try:
      exec code in environ

      req.flush()

      # Always ensure that session object is saved.

      if session is not None:
        session.save()

    except: 
      et,ev,etb = sys.exc_info()

      # Use error page to display details of error if
      # an actual error page was supplied.

      if interface.error_page:
        interface.error_page.run({"exception":(et,ev,etb)})

      else:
        raise et,ev,etb


# A servlet like handler for serving up PSP files. This
# class can be used where for a specific PSP file it is
# necessary to do more complicated things than what can
# sensibly be put in the PSP file itself. The servlet
# class should be used in conjunction with the wrapper
# class "vampire.Instance()" as it is written such that
# a new instance should be created for each request.

class Servlet:

  content_type = "text/html"

  def __init__(self,req):
    self.req = req
    self.vars = {}

  def render(self):

    path = os.path.splitext(self.req.filename)[0] + ".psp"

    self.req.content_type = self.content_type
    self.req.send_http_header()

    template = PSP(self.req,filename=path,vars=self.vars)
    template.run()

  def __call__(self):
    self.render()


# Basic handler for serving up PSP files. The handler
# name is appropriate for no extension being used,
# but the code accomodates use of any extension.

def handler(req):

  # We only want to treat request as being a possible
  # request for a PSP template file if there exists a
  # ".psp" file.

  path = os.path.splitext(req.filename)[0] + ".psp"

  if not os.path.exists(path):
    return apache.DECLINED

  # PSP template files are always HTML files.

  req.content_type = "text/html"

  # Trigger parsing of the PSP file. The file cache
  # for PSP files is still being used here.

  object = PSP(req,filename=path)

  # Execute the actual PSP template.

  object.run()


# Also link handler to that for ".html" and ".psp"
# requests. Which extension is used in the end is
# dictated by how settings are defined in the Vampire
# configuration file.

handler_html = handler                                                          
handler_psp = handler                                                          

