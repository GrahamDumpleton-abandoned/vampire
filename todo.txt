====
TODO
====

Following items are being considered for future version of Vampire.

- Lift restriction in "vampire::publisher" and "vampire.Publisher()" whereby
  only GET and POST requests can be handled. This restriction currently
  exists because that is what mod_python.publisher does.

  What is being considered is to support a similar mechanism to the user
  authentication and access hooks used by mod_python.publisher. This
  would involve the ability to define a list object or function with the
  name "__allow_methods__" which would override the default as to what HTTP
  request method types that a handler supports.

  For example, if "vampire::publisher" were being used, either of the
  following could be defined at file scope::

    # List of allowed methods.
    __allow_methods__ = ["GET","POST"]

    # Function dictating if method is allowed.
    def __allow_methods__(req,method):
      return method in ["GET","POST"]

  Similarly, it would be able to be defined at class scope using any
  of the follow approaches::

    class Object:

      # List of allowed methods.
      __allow_methods__ = ["GET","POST"]

      def __init__(self):
        # List of allowed methods.
        self.__allow_methods__ = ["GET","POST"]

      # Function dictating if method is allowed.
      def __allow_methods__(self,req,method):
        return method in ["GET","POST"]

  In practice, the definition of what is an allowed method at file scope or
  class scope, where multiple callable methods, would probably be too
  broad. Instead it should be defined on a case by case basis. Because it
  isn't possible to peak inside a function or method to look at data values
  which are of a list type, a nested function would need to be used::

    def publisher():

      # Function dictating if method is allowed.
      def __allow_methods__(req,method):
        return method in ["GET","POST"]

      return "CONTENT"

    class Object:

      def publisher():

        # Function dictating if method is allowed.
        def __allow_methods__(req,method):
          return method in ["GET","POST"]

        return "CONTENT"

  Addition of the feature would allow publishers to implement additional
  methods such as "PUT" and "DELETE", thereby lifting the restriction that
  only "GET" and "POST" can be handled.

- Investigate whether to add support for "HEAD" in "vampire::publisher".
  This would only work for case where a published function wasn't
  explicitly writing to the request object itself, in which case it should
  be checking for a "HEAD" request itself. Generally the purpose of using
  "HEAD" is to see if a document has changed since last request, but
  where content is dynamically generated everytime, does this even make
  any sense as content will not have a last modified time like a file
  would.

- Look at adding an equivalent to the Apache "ErrorDocument" directive but
  where the handler to generate the error page is specified within the
  Vampire configuration file. This would though only apply to errors which
  were generated from within the content handler.
  
  The intent of using the Vampire configuration file is that the location
  of the handler can be easily configured by using inbuilt variables such
  as "__config_root__" within the path. This gets around the problem with
  the "ErrorDocument" directive whereby the local URL which is used by
  Apache as input to an internal redirect has to be absolute. That Apache
  requires an absolute path means it is necessary to hard code fixed paths
  into ".htaccess" files which would have to be changed all the time if the
  web application is relocated within the URL namespace. Using Vampire for
  this job would avoid this problem.

  To avoid any unwanted overhead, the feature would only be enabled if the
  Python option "VampireErrorHandlers" is set to "On"::

    PythonOption VampireErrorHandlers On

  The section in the Vampire configuration which would be consulted would
  be the same as that for default handlers. The setting name to use for
  the handler for a specific error would be "errorhandler_NNN" where "NNN"
  is the error number. For example::

    errorhandler_404 = %(__config_root__)s/_error_404.py

  The name of the handler function within the Python code file identified
  would have the same name as the name of the variable used to set it. If
  the "defaults" variable had been set to identify a common module for
  handlers, it would also be consulted if the setting for a specific
  error value is not set explicitly.

  If a single handler was required for all errors, then would also be
  possible to define "errorhandler" without an error number suffix::

    errorhandler = %(__config_root__)s/_error.py

  When the error handler is called, it would be called with the "req"
  object passed to the original content handler which generated the error.
  This would be the exact same object. That is, an internal redirect would
  not be performed, so any data stored in the "req" object or any form
  parameters would still be accessible.

  The error number would be stored in the "req" object as "req.status"
  when the error handler is called. After rendering an appropriate page
  the error handler would have to return "apache.OK", or as per Vampire
  convention it could just return "None" or no return value at all. If
  "apache.DECLINED" were returned, the original error status would be
  propogated back and Apache would be left to render the error page. If
  any other error were returned or raised, that would be propogated up
  and allowed to replace the original error.
  
  Note that the above wouldn't apply to "vampire::publisher" as it is
  outside of what the original mod_python.publisher was capable of doing.
  If using "vampire.Publisher()" within the context of a standard
  Vampire content handler, the feature would then be available.

- Contemplate applying rules for creating structured form values to the
  keys in a configuration file. This would allow::

    [Settings]

    elements-1 = one
    elements-2 = two

  The result of accessing "elements" would then be a list containing both
  values. Similarly for dictionaries. Overall this would allow structured
  data in the configuration files, albeit with values still being strings.

- See if there is any way possible that the Vampire import mechanism could
  support packages.
