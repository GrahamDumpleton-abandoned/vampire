====
TODO
====

Following items are being considered for future version of Vampire.

- Lift restriction in "vampire::publisher" and "vampire.Publisher()" whereby
  only GET and POST requests can be handled. This restriction currently
  exists because that is what mod_python.publisher does.

  What is being considered is to support a similar mechanism to the user
  authentication and access hooks used by mod_python.publisher. This
  would involve the ability to define a list object or function with the
  name "__allow_methods__" which would override the default as to what HTTP
  request method types that a handler supports.

  For example, if "vampire::publisher" were being used, either of the
  following could be defined at file scope::

    # List of allowed methods.
    __allow_methods__ = ["GET","POST"]

    # Function dictating if method is allowed.
    def __allow_methods__(req,method):
      return method in ["GET","POST"]

  Similarly, it would be able to be defined at class scope using any
  of the follow approaches::

    class Object:

      # List of allowed methods.
      __allow_methods__ = ["GET","POST"]

      def __init__(self):
	# List of allowed methods.
	self.__allow_methods__ = ["GET","POST"]

      # Function dictating if method is allowed.
      def __allow_methods__(self,req,method):
	return method in ["GET","POST"]

  In practice, the definition of what is an allowed method at file scope or
  class scope, where multiple callable methods, would probably be too
  broad. Instead it should be defined on a case by case basis. Because it
  isn't possible to peak inside a function or method to look at data values
  which are of a list type, a nested function would need to be used::

    def publisher():

      # Function dictating if method is allowed.
      def __allow_methods__(req,method):
	return method in ["GET","POST"]

      return "CONTENT"

    class Object:

      def publisher():

	# Function dictating if method is allowed.
	def __allow_methods__(req,method):
	  return method in ["GET","POST"]

	return "CONTENT"

  Addition of the feature would allow publishers to implement additional
  methods such as "PUT" and "DELETE", thereby lifting the restriction that
  only "GET" and "POST" can be handled.

- Investigate how an option can be provided to turn off automatic module
  reloading for the Vampire module loading and caching system.

  In mod_python itself module reloading is turned off by using the option
  "PythonAutoReload". This mechanism is however unreliable because it can
  can be set to different values in different parts of the document tree.
  Further, explicit use of the "apache.import_module()" function doesn't
  consult this option. Instead, it is expected that the caller supply
  through a parameter whether module reloading is enabled or not.
  
  Thus for the module loading system in mod_python, a request to load a
  module via a request through one part of the document tree may cause a
  automatic reload whereas through another part of the document tree it may
  not. This can cause inconsistencies as far as expectations as to what
  version of a module is loaded.

  The only reliable mechanism would be to allow module reloading to be on
  or off for the complete lifetime of a particular interpreter. In other
  words, automatic module reloading should be off from the point the
  interpreter is created until the process is terminated.
  
  The only way of achieving this would be for the "PythonImport" directive
  to be used to load a special module from which a call is made to disable
  automatic module reloading from that point onwards. If at the point the
  call was made a module has already been loaded, one may well have to leave
  automatic reloading on. In other words, it would have to be called prior to
  the very first module being loaded or it has no affect in disabling of
  automatic module reloading.

- Look at adding an equivalent to the Apache "ErrorDocument" directive but
  where the handler to generate the error page is specified within the
  Vampire configuration file. This would though only apply to errors which
  were generated from within the content handler.
  
  The intent of using the Vampire configuration file is that the location
  of the handler can be easily configured by using inbuilt variables such
  as "__config_root__" within the path. This gets around the problem with
  the "ErrorDocument" directive whereby the local URL which is used by
  Apache as input to an internal redirect has to be absolute. That Apache
  requires an absolute path means it is necessary to hard code fixed paths
  into ".htaccess" files which would have to be changed all the time if the
  web application is relocated within the URL namespace. Using Vampire for
  this job would avoid this problem.

  To avoid any unwanted overhead, the feature would only be enabled if the
  Python option "VampireErrorHandlers" is set to "On"::

    PythonOption VampireErrorHandlers On

  The section in the Vampire configuration which would be consulted would
  be the same as that for default handlers. The setting name to use for
  the handler for a specific error would be "errorhandler_NNN" where "NNN"
  is the error number. For example::

    errorhandler_404 = %(__config_root__)s/_error_404.py

  The name of the handler function within the Python code file identified
  would have the same name as the name of the variable used to set it. If
  the "defaults" variable had been set to identify a common module for
  handlers, it would also be consulted if the setting for a specific
  error value is not set explicitly.

  When the error handler is called, it would be called with the "req"
  object passed to the original content handler which generated the error.
  This would be the exact same object. That is, an internal redirect would
  not be performed, so any data stored in the "req" object or any form
  parameters would still be accessible.

  The error number would be stored in the "req" object as "req.status"
  when the error handler is called. If the error handler doesn't have a
  return value, ie., the default of "None", the original error number is
  preserved. The original error status will also be preserved if
  "apache.OK" is returned. If any error number is returned or raised as an
  exception then it will override the original error status value.

  Note that the above wouldn't apply to "vampire::publisher" as it is
  outside of what the original mod_python.publisher was capable of doing.
  If using "vampire.Publisher()" within the context of a standard
  Vampire content handler, the feature would be available.
