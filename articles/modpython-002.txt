==========================
Module Importing is Broken
==========================

:Author: Graham Dumpleton
:Contact: grahamd@dscpl.com.au
:Updated: 26/06/2005

.. contents::


This article describes various problems that exist with the module
importing system which is included with mod_python along with suggestions
as to where improvements could be made. Its purpose is to highlight in one
spot the problems so that users are aware of them, but also to serve as a
basis for discussion for moving forward and fixing any bugs or generally
improving the module importing mechanism. The descriptions here are based
on the state of mod_python as of version 3.1.3. Some of the issues have
already been addressed for the next version of mod_python but are described
here anyway.


Overview of Module Importing
############################

First up an overview is given of the key points of what the module
importing system comprises and how it is used.


Module Import Function
======================

The module importing system in mod_python is all based upon the Python
function "import_module()" contained in the "mod_python.apache". This
function is used to import modules which have been specified by any of the
"Python*Handler", "Python*Filter" or "PythonConnectionHandler" directives.
It is not however used for any modules imported using the "PythonImport"
directive. In this final case, the standard Python C API import functions
are used.

The "import_module()" function may also be used explicitly from within any
Python code executing within the context of mod_python. For example, the
"import_module()" method is used by mod_python.publisher to import
individual Python code files held within the document tree. Having loaded
such a code file as a module, mod_python.publisher will then map URLs into
calls against distinct functions contained within the module.

One of the main reasons for the existance of the "import_module()" method
is to facilitate the provision of a mechanism for the automatic reloading
of modules when the code file kept on disk has changed. Unfortunately the
effectiveness of this is limited due to shortcomings in the design of the
module importing system along with a number of bugs in the current
implementation. The nature of how the module importing system works in
relation to the existing Python module importing system also raises
issues in respect of a multithreaded system along with a number of other
problems.


The Handler Directives
======================

The handler directives are placed into the main Apache configuration file
or into a ".htaccess" file contained within the appropriate directory in
the document tree. These directives are used to specify the module
containing the handler function to be executed for a particular phase of
processing.

For example, to specify that the mod_python supplied mod_python.publisher
module should be used for the content handling phase of any request where a
".py" extension were used, the main Apache configuration file would need to
contain::

  <Directory /some/path>
  AddHandler python-program .py
  PythonHandler mod_python.publisher .py
  </Directory>

Alternatively, if you wished to use your own custom handler for the content
handling phase of any request made against the directory, and it was stored
within the same directory for which mod_python was being enabled, you might
instead use::

  <Directory /some/path>
  AddHandler python-program .py
  PythonHandler myhandler
  </Directory>

In the case of mod_python.publisher, the module would normally be installed
into the "site-packages" directory of the Python distribution. As such, it
will be found by a search of the default Python module search path.

For the case of the custom handler however, it isn't installed into the
"site-packages" directory, nor in any other directory contained in the
Python module search path. This means that it will not be able to be
located when Python is asked to load it.

To avoid this problem, mod_python will automatically insert at the head of
the Python module search path, the root directory within the document tree
for which the PythonHandler directory was specified. This having been done,
the module containing the custom handler will now be able to be found.

If a custom handler is not placed into the root directory of the document
tree where mod_python is enabled, nor is it located within any directory
listed in the Python module search path, it will be necessary to override
the Python module search path to contain the directory where it is located.

The Python module search path can be overridden using the "PythonPath"
directive. For example, if the custom handler were actually located within
a subdirectory of the root directory where mod_python was enabled, the main
Apache configuration would then need to be defined as::

  <Directory /some/path>
  PythonPath "['/some/path/modules']+sys.path"
  AddHandler python-program .py
  PythonHandler myhandler
  </Directory>

As the "PythonPath" directive will replace the prior value of the Python
module search path, it is necessary when merely wishing to extend it to
reference the prior value. In effect, the value specified for the
"PythonPath" directive is evalulated and thus one can use the Python
language itself to construct the new value for the path. The final value
must be a list of strings where each string is the path name of a
directory to be searched.

Note that setting the "PythonPath" directive explicitly will result in the
root directory of the document tree for which mod_python was enabled, no
longer being added into the Python module search path. That is, the value
specified by the "PythonPath" directive takes precedence for that directory
and anything below it. Using the "PythonHandler" directive in a
subdirectory will not even undo this, even when used within the context of
a distinct interpreter. The "PythonPath" directive should there before used
with great caution and not at all if possible.


Explicit Import of Modules
==========================

When using mod_python, instead of using the "import" statement to import
modules, the "import_module()" function can be used. The benefits of using
the "import_module()" function are that the exact location of the module
can be specified, avoiding the need for the directory containing the module
to be added into the Python module search path. Using the "import_module()"
function, it is also easier to import arbitrarily named modules the names
of which will not be known of in advance, as the name of the module is
supplied as an argument of the function and doesn't need to be hard coded
as a syntactical argument of the import statement.

The prototype for the "import_module()" function is as follows::

  import_module(module_name,autoreload=1,log=0,path=None)

The only required parameter is that of the module name. In supplying only
the module name, a search will be made of the Python module search path. If
the "path" parameter is supplied, it should be a list of directories to
search for the module. To load a module from a particular location, the
"path" parameter would be a list containing just the directory containing
the desired module.

The "import_module()" method can feasibly be used at global scope within a
module, or within an actual handler function executed as a consequence of a
request. To import a module from the same directory as the handler, the
location can be derived from the special "__file__" variable present within
a module.

::

  from mod_python import apache
  import os

  directory = os.path.dirname(__file__)
  module1 = apache.import_module("module1",path=[directory])

  def handler(req):
    module2 = apache.import_module("module2",path=[directory])
    package1 = apache.import_module("package1",path=[directory])
    package2 = apache.import_module("package1.package2",path=[directory])
    module3 = apache.import_module("package1.module3",path=[directory])
    ...

As well as file based modules, the "import_module()" can also be used to
import the root of a package, or a sub package/module of a package. Whereas
when using the "import" statement to import a sub package/module still
requires access to the module to be via the root package name, the
"import_module()" function returns a direct reference to the sub
package/module.


Auto Reload Mechanism
=====================

In the context of a module specified using a handler directive, the intent
of the automatic module reloading mechanism is that when the code file
corresponding to the handler is changed on disk, that this will be detected
the next time a request arrives which would require the handler to be
executed. Having detected this change, the module will first be reloaded
and only then will the handler be executed.

Whether or not automatic module reloading is enabled for a handler
specified using a handler directive is controlled by the "PythonAutoReload"
directive. By default automatic module reloading is enabled at this level
and it would need to be explicitly disabled if it wasn't required, such as
in a production environment.

When using the "import_module()" function explicitly from within a handler
module, whether the automatic module reloading mechanism is enabled is
controlled through the "autoreload" argument. By default, automatic module
reloading is enabled at this level as well and would need to be explicitly
disabled to stop it from occurring. This can only be done by supplying a
value to the "autoreload" argument which evaluates to false. The
"PythonAutoReload" directive has absolutely no affect in this circumstance.

For a module being imported by an explicit call to the "import_module()"
function from within the context of a handler being executed in response to
a request, whether the module is up to date will be evaluated for each
request. If the module has been changed on disk, it will be reimported
at the time of the handler being executed.

If the importing of the module by an explicit call to the "import_module()"
function is performed at global scope within a module, whether the child
module has changed and whether it needs to be reimported, is only
determined at the time that the parent module is first imported and when
the parent module is subsequently reimported.


Logging of Module Imports
=========================

For a module specified using a handler directive, the fact that the module
is imported or subsequently reimported will only be logged to the Apache
log file if the "PythonDebug" option is enabled. By default this option is
disabled.

Enabling of the debug option has other consequences though besides logging
information to the log file about imports. Specifically, if debugging is
enabled and an error occurs within a handler, the details of the Python
error and the trace back will be returned in the error page to the client
making the request.

Where explicit use is made of the "import_module()" function, to have
whether or not a module is being imported can only be enabled by supplying
a value as the "log" argument argument which evaluates to true. The
"PythonDebug" directive has absolutely no affect in this circumstance.


Catalogue of Problems/Issues
############################

Now for a catalogue of the various problems and issues. Some will argue
that some of these are minor and this is true, but the aim here is to look
at improving what is there as well as fixing any bugs.


Configuration of Logging
========================

Because the only way to enable logging when using the "import_module()"
function explicitly is by supplying the "log" argument to the function
itself, there is no effective way of enabling logging of imports globally
in one place **[ISSUE 1]**.

This is the case, because although the "req" object is available within the
context of a handler and could be queried as to the state of the
"PythonDebug" setting, the same cannot be done at global scope in a module.
Either way, it places extra work on the user to make this explicit check
to determine if logging should be enabled or not.

::

  from mod_python import apache
  import os

  directory = os.path.dirname(__file__)

  # No way to determine from the Apache configuration at
  # global scope what the "log" argument should be set to.

  module1 = apache.import_module("module1",path=[directory])

  def handler(req):
    log = req.get_config().get("PythonDebug",0)
    module2 = apache.import_module("module2",log=log,path=[directory])
    ...

Even in a production environment where "PythonDebug" may be disabled to
prevent internal details of Python related errors being returned to a
client making a request, being able to get out information about when
module imports are occuring is still useful. Because the logging of this
information is bound to the "PythonDebug" directive, it cannot be
separately enabled **[ISSUE 2]**.

During debugging, to know when a module is being imported for the first
time, as opposed to it being reloaded at a later time, can be important.
At present the messages which are logged do not in general distinguish
between the two cases of an initial import and a subsequent reimport of
the same module **[ISSUE 3]**.


Redundant Module Reloads
========================

Whether on the first import or a subsequent reload, if a multithreaded MPM
is being used and multiple threads call into the "import_module()" function
at the same time for the same module, the module can be loaded more than
once even though it isn't required **[ISSUE 4]**. Separate PATCHES_ are
available for this problem.

.. _PATCHES: ../patches.html

This is because of a lack of thread locks on the module cache. Multiple
threads can at the same time determine that the module needs to be
reloaded. Although this occurs, the locks implicit within the underlying
Python module importing system prevents each thread from importing the
actual module at the same time. Each thread will however in turn still
separately import the module with all imports except for the first being
redundant.


Going Backwards in Time
=======================

When ascertaining if a module has been changed on disk since the last time
it was loaded, mod_python will only consider the file as having changed if
the modification time is newer than that which it was previously. This
means you cannot restore an older file from a backup with a modification
time earlier than the current file **[ISSUE 5]**. You would need to
physically touch the file to make the modification time newer than that of
the file being replaced in order to force it to be reloaded. This issue
is further described in JIRA as `MODPYTHON-7`_.

.. _MODPYTHON-7: http://issues.apache.org/jira/browse/MODPYTHON-7


Packages Loaded Wrongly
=======================

The "import_module()" function can be used to load either a standalone file
based module or a package. It can also be used to load a sub module/package
from within a package.

When loading a sub module/package which wasn't implicitly loaded when the
package root was imported, the "import_module()" function does not insert a
reference to the sub module/package into the appropriate parent module
within the package **[ISSUE 6]**. This issue is further described in JIRA
as `MODPYTHON-12`_.

.. _MODPYTHON-12: http://issues.apache.org/jira/browse/MODPYTHON-12

The problem means that if mod_python.publisher or mod_python.psp are loaded
as the PythonHandler and at a later point a handler attempts to use the
Python import statement on these sub modules of the mod_python package,
they will not be able to be found. This is because the reference to the
sub modules is not registered in the mod_python module as "publisher"
and "psp" appropriately.


Disabling of AutoReload
=======================

Similar to the problem of enabling/disabling logging of module reloads,
disabling of the autoreload feature for modules cannot be turned off
globally in one place **[ISSUE 7]**.

This is because although the PythonAutoReload directive can be used to
disable top level handler imports, it does not control whether autoreload
is enabled for explicit use of the "import_module()" function. In this case
it is up to the user to somehow determine whether the autoreload feature
should be disabled and pass an explicit argument to the "import_module()"
function call to disable it for that specific call. As shown for logging,
the request object is not accessible when code at global scope within a
module is being executed and so any configuration cannot be consulted.

This is made worse by the fact that different parts of the document tree
can have the autoreload feature enabled at the same time it is disabled
elsewhere. The problem that arises here is that a module may get reloaded
when not expected resulting in an mismatch in versions of code being used.

Being able to have the autoreload feature selectively enabled/disabled in
distinct parts of the document tree is useful, however, there should
probably also be a way of globally disabling the autoreload feature for
that whole interpreter from that point onwards until a restart. This would
override any attempt to selectively disable/enable the feature in selected
parts of the document tree.


What About the Children
=======================

Where the Python code file for a module which is referenced in a Handler
directive is changed and the autoreload feature is enabled, that Python
code file will be reloaded before the handler is executed. If at global
scope within this module the "apache.import_module()" function had been
explicitly used to import a child module and rather than the top level
module code file being modified, the code file for the child module is
changed, nothing is reloaded **[ISSUE 8]**.

The only way to currently force the reloading of the child module is to
manually touch the top level module to change its modification time as
well, thereby triggering a reload of the parent and the child. Note that if
there is multiple levels of imports, one in practice has to manually touch
all ancestor modules of the module which was changed, right back up to the
root module. If the child module was imported from multiple places, all
ancestors through all parents should be touched to ensure that all parents
are reloaded as necessary.


Mixing It Up With Import
========================

Because the Python module search path is extended with the directory in the
document tree where the Handler directive is defined, it is possible for a
module contained within the document tree to be imported from different
places using the "import" statement and the "apache.import_module()"
function **[ISSUE 9]**.

This is in effect the underlying trigger for **[ISSUE 6]** although that
issue is a distinct problem in its own right because of how packages are
incorrectly handled.

When the "import" statement is first used to import a module and that
module is later requested to be imported using the "apache.import_module()"
function, that later request will result in a redundant reload of the
module. This is because the "apache.import_module()" function places a
"__mtime__" attribute in the module as part of the scheme to determine when
to reload a module. Where "import" was first used to import the module,
that attribute will not exist and its value will default to "0", causing
"apache.import_module()" to think it is out of date and reload it.


Reloading of Packages
=====================


Overwriting Global Data
=======================


Have I Seen You Before
======================


